typedef TokenType byte;

struct Token {
	// What is looks like in the actual source
	data string

	// What the token is depicting
	kind TokenType

	// What line this token comes from
	line int
}

const T_ILLEGAL TokenType = 0;

// Keywords
const T_FOR TokenType = 1;
const T_RANGE TokenType = 2;
const T_FOREVER TokenType = 3;
const T_WHILE TokenType = 4;
const T_IF TokenType = 5;
const T_ELIF TokenType = 6;
const T_ELSE TokenType = 7;
const T_CALL TokenType = 8;
const T_STRUCT TokenType = 9;
const T_FUN TokenType = 10;
const T_RET TokenType = 11;
const T_BREAK TokenType = 12;
const T_CONT TokenType = 13;
const T_ENUM TokenType = 14;
const T_TYPEDEF TokenType = 15;
const T_NEW TokenType = 16;
const T_MAKE TokenType = 17;
const T_MAP TokenType = 18;
const T_SWITCH TokenType = 19;
const T_CASE TokenType = 20;
const T_DEFAULT TokenType = 21;
const T_CONST TokenType = 22;

// Various symbols
const T_SEMICOLON TokenType = 23;
const T_ASSIGN TokenType = 24;
const T_SEP TokenType = 25;
const T_COLON TokenType = 26;

// Operators
const T_ADD TokenType = 27;
const T_SUB TokenType = 28;
const T_MUL TokenType = 29;
const T_DIV TokenType = 30;
const T_OR TokenType = 31;
const T_AND TokenType = 32;
const T_OROR TokenType = 33;
const T_ANDAND TokenType = 34;
const T_EQ TokenType = 35;
const T_LT TokenType = 36;
const T_GT TokenType = 37;
const T_LTEQ TokenType = 38;
const T_GTEQ TokenType = 39;
const T_NEQ TokenType = 40;
const T_MOD TokenType = 41;
const T_XOR TokenType = 42;
const T_ACCESS TokenType = 43;
const T_NOT TokenType = 44;
const T_INC TokenType = 45;
const T_DINC TokenType = 46;
const T_REF TokenType = 47;
const T_DEREF TokenType = 48;
const T_L_SHIFT TokenType = 49;
const T_R_SHIFT TokenType = 50;

// Paired symbols
const T_L_SQUIRLY TokenType = 51;
const T_R_SQUIRLY TokenType = 52;
const T_L_BLOCK TokenType = 53;
const T_R_BLOCK TokenType = 54;
const T_L_PAREN TokenType = 55;
const T_R_PAREN TokenType = 56;

// Values
const T_TYPE TokenType = 57;
const T_IDENTIFIER TokenType = 58;
const T_INT TokenType = 59;
const T_FLOAT TokenType = 60;
const T_STRING TokenType = 61;
const T_CHAR TokenType = 62;
const T_BOOL TokenType = 63;
const T_NIL TokenType = 64;

fun (t TokenType) String() string {
	switch t {
	case T_ILLEGAL:
		return "ILLEGAL";

	// Keywords
	case T_FOR:
		return "FOR";
	case T_RANGE:
		return "RANGE";
	case T_FOREVER:
		return "FOREVER";
	case T_WHILE:
		return "WHILE";
	case T_IF:
		return "IF";
	case T_ELIF:
		return "ELIF";
	case T_ELSE:
		return "ELSE";
	case T_CALL:
		return "CALL";
	case T_STRUCT:
		return "STRUCT";
	case T_FUN:
		return "FUN";
	case T_RET:
		return "RET";
	case T_BREAK:
		return "BREAK";
	case T_CONT:
		return "CONT";
	case T_ENUM:
		return "ENUM";
	case T_TYPEDEF:
		return "TYPEDEF";
	case T_NEW:
		return "NEW";
	case T_MAKE:
		return "MAKE";
	case T_MAP:
		return "MAP";
	case T_SWITCH:
		return "SWITCH";
	case T_CASE:
		return "CASE";
	case T_DEFAULT:
		return "DEFAULT";
	case T_CONST:
		return "CONST";

	// Various symbols
	case T_SEMICOLON:
		return "SEMICOLON";
	case T_ASSIGN:
		return "ASSIGN";
	case T_SEP:
		return "SEP";
	case T_COLON:
		return "COLON";

	// Operators
	case T_L_SHIFT:
		return "T_L_SHIFT";
	case T_R_SHIFT:
		return "T_R_SHIFT";
	case T_ADD:
		return "ADD";
	case T_SUB:
		return "SUB";
	case T_MUL:
		return "MUL";
	case T_DIV:
		return "DIV";
	case T_OR:
		return "OR";
	case T_AND:
		return "AND";
	case T_OROR:
		return "OROR";
	case T_ANDAND:
		return "ANDAND";
	case T_EQ:
		return "EQ";
	case T_LT:
		return "LT";
	case T_GT:
		return "GT";
	case T_LTEQ:
		return "LTEQ";
	case T_GTEQ:
		return "GTEQ";
	case T_NEQ:
		return "NEQ";
	case T_MOD:
		return "MOD";
	case T_XOR:
		return "XOR";
	case T_ACCESS:
		return "ACCESS";

	// Unary
	case T_NOT:
		return "NOT";
	case T_INC:
		return "INC";
	case T_DINC:
		return "DINC";
	case T_REF:
		return "REF";
	case T_DEREF:
		return "DEREF";

	// Paired symbols
	case T_L_SQUIRLY:
		return "L_SQUIRLY";
	case T_R_SQUIRLY:
		return "R_SQUIRLY";
	case T_L_BLOCK:
		return "L_BLOCK";
	case T_R_BLOCK:
		return "R_BLOCK";
	case T_L_PAREN:
		return "L_PAREN";
	case T_R_PAREN:
		return "R_PAREN";

	case T_TYPE:
		return "TYPE";
	case T_IDENTIFIER:
		return "IDENTIFIER";
	case T_INT:
		return "INT";
	case T_FLOAT:
		return "FLOAT";
	case T_STRING:
		return "STRING";
	case T_CHAR:
		return "CHAR";
	case T_BOOL:
		return "BOOL";
	case T_NIL:
		return "NIL";
	default:
		return "UNKNOWN";
	}
}

fun (t Token) String() string {
	return "(" + t.data + " " + call t.kind.String() + ")";
}
